# E-commerce 동시성 문제

### 동시성의 정의

> 동시성은 **여러 작업이 독립적으로 실행**되며, 그 실행이 **논리적으로 동시에 일어나는 것처럼**보이게 하는 프로그래밍 기법

## 동시성으로 인한 문제

### 1. **경쟁 상태, 경쟁 조건(Race condition)**
- 두 개 이상의 스레드가 동시에 공유자원에 접근할 때 발생
- 스레드 실행 순서에 따라 결과가 달라짐
- 예시
  - `balance` 에 대한 충전과 사용 요청이 동시에 접근하여, 아직 갱신되지 않은 잔액을 기준으로 서로 나중에 완료되는 요청으로 갱신이 될 수 있음
  - 이로 인해 분실 갱신이 발생하여 정합성이 깨지고 데이터 불일치가 발생함

### 2. **데드락(Deadlock)**
- 두 개의 스레드가 서로 상대방이 점유하고 있는 자원을 무한정 대기하는 상태
- 발생 조건
  - 상호 배제: 자원은 하나의 프로세스만 점유 가능
  - 점유와 대기: 자원을 점유한 채로 다른 자원을 기다림
  - 비선점: 자원을 강제로 가져오지 못함
  - 순환 대기: 프로세스들이 서로 원형으로 대기함
- 예시 1
  - 상품 > 쿠폰 > 잔액을 접근하는 주문 메서드를 호출한 스레드와
  - 쿠폰 > 상품을 접근하는 다른 메서드가 동시에 요청이 발생 했을 떄,
  - 각각의 요청이 상품과 쿠폰을 선점하고 서로 다른 자원을 기다리는 교착상태에 빠짐
- 예시 2
  - 두 주문 요청이 발생하는 중, 상품 한 테이블에 대하여 PK에 대한 순서 정렬 없이 재고 차감을 하는 경우
  - 3 > 1 > 5 번 상품 재고를 차감하려는 주문 요청
  - 1 > 3 번 상품 재고를 차감하려는 주문의 경우 
  - PK 기준으로 row에 락이 동작해 서로 다음 상품의 재고 차감을 하지 못하도 교착상태에 빠짐

### 3. 라이브락(Livelock)
- 여러 스레드나 프로세스가 서로의 작업을 방해햐여 진행이 멈춘 상태
- 데드락과 유사하지만, 데드락과 달리 스레드들이 작업을 지속적으로 시도함

### 4. 기아 상태(Starvation)
- 특정 스레드나 프로세스가 자원에 대한 접근 권한을 지속적으로 얻지 못하고 무한정 대기하는 상태
- 우선순위가 낮거나, 잘못된 자원할당 정책에서 발생할 수 있는 상황

### 5. 우선순위 역전(Priority Inversion)
- 실시간 시스템에서 낮은 우선순위의 태스크가 높은 우선순위의 태스크보다 먼저 자원을 점유하여 높은 우선순위 태스크의 실행을 지연시키는 문제

## E-commerce 서비스에서 예측되는 동시성 문제

### 1. 상품 재고 차감
- 기능 설명: 주문 생성 중 상품의 재고를 차감하는 경우
- 예측되는 동시성 문제: `Race condition` → 재고 음수 발생, 차감 누락
- 발생 시나리오
  - 상품 A의 `재고 5` 일 때, 두 사용자의 요청으로 각각 `수량 3`을 주문
  - 두 트랜젝션이 모두 `Product.stock >= quantity`를 충족
  - 둘 다 차감하고 커밋하면 최종 `재고 -1`
  - 혹은 업데이트를 위해 조회한 5를 기준으로 나중의 것이 덮어쓰기 되어 `재고 2`
- 비즈니스적 문제
  - 실제보다 많은 수량을 판매한 것처럼 기록되어 오배송, 품절, 환불 요청 등으로 재고 관리의 어려움 발생
  - 물류를 직접 다루는 도메인에서는 실패를 감내하기 어려움

### 2. 쿠폰 선착순 발급
- 기능 설명: 쿠폰 정책별 잔여 수량에 대하여 사용자에게 쿠폰을 발급 하는 경우
- 예측되는 동시성 문제: `Race condition` → 쿠폰 초과 발급
- 발생 시나리오
  - remainingCount = 1 일 때, 두 사용자가 동시에 발급 요청
  - 두 요청 모두 `remainingCount > 0` 조건을 충족
  - 둘 다 반영되어 최종 잔여가 -1이 되거나, 사용자 각각의 잘못된 쿠폰이 초과 발급
- 비즈니스적 문제
  - 예산을 초과하는 쿠폰 발급으로 인한 마케팅 비용에 손실이 있음
  - 공정성 문제가 발생하고, 사용자의 신뢰도가 하락함
  - 발생하지 않는 것이 제일 좋지만, 마케팅과 사후 안내를 통한 소량의 초과 발급분 까지 인정하고,
  - 회사의 손실보다 사용자의 이익이 강조되는 상황에선 역으로 마케팅이 가능하여 어느 정도 실패를 감내할 수 있음    

### 3. 쿠폰 사용
- 기능 설명: 주문 생성 중 쿠폰을 사용하는 경우
- 예측되는 동시성 문제: `Race condition` → 쿠폰의 중복 사용
- 발생 시나리오
  - 정상적으로 발급된 쿠폰 A에 대하여, 한 사용자가 두 번의 주문을 동시에 요청
  - 요청 시 둘 다 `used == false` 조건으로 사용 상태로 업데이트
  - 하나의 쿠폰이 두번 사용됨
- 비즈니스적 문제
  - 쿠폰 관리 시스템에 대한 신뢰도 저하
  - 악용 사례로 인한 부수적인 피해 발생
  - 발급된 쿠폰에 대한 접근은 발급을 받은 사용자 한명에게만 유효하여 한 주문에 실패 정도는 감내 가능 

### 4. 잔액 차감
- 기능 설명: 주문 생성 중 잔액을 차감하는 경우
- 예상되는 동시성 문제: `Race condition` → 잔액의 중복 차감, 덜 차감
- 발생 시나리오
  - 사용자 A의 잔액이 `5,000`인 상태에서, 총액 `3,000`, `4,000`의 주문 동시 발생
  - 조건 `5,000 >= 주문금액`을 모두 통과하고, 음수 잔액 `-2,000` 혹은, 두 개의 주문 총액보다 덜 차감됨
- 비즈니스적 문제
  - 음수 잔액으로 인한 후속 결제 문제, 공급사가 별도로 있다면 정산에도 오류가 발생
  - 일부 월말 통합 결제, 미수금 결제 등 B2B 사업에서는 허용될 수 있으나,
  - 충전식으로 사용되는 e-commerce 서비스에서는 신뢰성이 크게 하락할수 있음. 
  - 다만, 잔액은 사용자 단위의 자원이므로, 한 주문 요청을 실패시키는 것에 대한 감내 가능.

### 5. 잔액 충전 및 사용
- 기능 설명: 잔액 충전 요청과 동시에 주문 생성을 통한 잔액차감 발생
- 예상되는 동시성 문제: `Race condition` → 충전과 차감이 충돌하여 잔액 오류 발생
- 발생 시나리오
  - 사용자 A가 잔액이 `5,000`이 있는 상태에서, `3,000`의 주문과 `3,000`의 충전을 동시에 요청
  - 충전 및 사용에 조건이 동시에 통과해 동시에 잔액을 참조
  - 주문보다 충전이 늦게 완료되어 주문 금액이 무시되고, 충전 금액으로 덮어쓰기 됨
- 비즈니스적 문제
  - 충전 후에도 잔액이 감소되어있거나, 반대로 사용했음에도 잔액이 남아있어 신뢰성이 무너짐
  - 다만, 잔액은 사용자 단위의 자원이므로, 한가지 요청을 실패시키는 것으로 감내 가능.

### 6. 주문 생성 전체 흐름
- 기능 설명: 하나의 트랜잭션 내에서 3개의 자원(Product, Coupon, Balance)을 함께 처리
- 예상 동시성 문제: `Deadlock` → 교착 상태 발생
- 발생 시나리오 1
  - 주문 생성 트랜젝션: 상품 → 쿠폰 → 잔액 순으로 접근
  - 주문 생성 외 트랜젝션: 쿠폰 → 상품, 또는 잔액 → 상품 순서 처럼 역방향으로 접근
  - 서로 자원 점유 순서가 다르면 서로 다른 자원 점유 후 상대 자원 대기
  - 주문 생성 OrderFacade에서 Product > Coupon > Balance 순으로 프로세스 동작
  - 현재 시나리오 상으로는 발생 가능성이 낮음
- 발생 시나리오 2
  - 주문 상품의 정렬 없이, 상품 목록 `[1, 3, 5]`와 `[3, 1]`의 주문이 동시에 요청됨
  - PK 1과 3의 자원을 점유한 상태로 교착 상태에 빠짐
- 비즈니스적 문제
  - 교착 상태로 인한 지속적인 주문 실패는 매우 크리티컬 하여, 서비스 전체적인 신뢰도가 하락함
  - 반복적인 재시도 및 CS 요청 처리가 지속적으로 발생
  - 교착 상태는 감내할 수 없는 치명적인 장애로, 반드시 배제할 수 있도록 예방 설계가 필요





